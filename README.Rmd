---
title: "d.d.i. (Data Defect Index) for non i.i.d. Samples"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

A simple set of functions to implements Meng's Data Defect Index (d.d.i.).  

> Xiao-Li Meng. 2018. "Statistical paradises and paradoxes in big data (I): Law of large populations,  big data paradox, and the 2016 US presidential election." Annals of Applied  Statistics 12:2, 685â€“726. https://doi.org/10.1214/18-AOAS1161SF. 

([ungated version](https://statistics.fas.harvard.edu/files/statistics-2/files/statistical_paradises_and_paradoxes.pdf))


## Install

```{r, eval = FALSE}
# install.packages("devtools")
remotes::install_github("kuriwaki/ddi")
```



# Usage

With a dataframe with columns for a group's estimates and components of the formula, `ddc` computes the data defect correlation ($\rho$).

An example dataset from the 2016 Election is included (this also serves as the replication dataset for the AOAS article). This looks like

```{r, message = FALSE}
library(ddi)
library(tidyverse)

data(g2016)
g2016
```

We can compute the data defect correlation just by plugging in some numbers. For example
```{r}
ddc(mu = 62984824/136639786, muhat = 12284/35829, N = 136639786, n = 35829)
```

and the d.d.i. is the square of that, about `r formatC(ddc(mu = 62984824/136639786, muhat = 12284/35829, N = 136639786, n = 35829)^2, digits = 7, format = "f")`. 

we got these numbers by 
```{r}
select(g2016, cces_totdjt_vv, cces_n_vv, tot_votes, votes_djt) %>%
  summarize_all(sum)
```

where 

* `cces_totdjt_vv`: The count of Trump voters (among validated voters)
* `cces_n_vv`: The count of CCES valiated voters (sample size)
* `votes_djt`: Total votes for Trump
* `tot_votes`: Total turnout
* `cces_pct_djt_vv`: Estiamted vote share, `cces_totdjt_vv / cces_n_vv`
* `pct_djt_voters`: Estiamted vote share, `votes_djt / tot_votes`


The function also takes vectors as inputs:
```{r}
with(g2016, ddc(mu = pct_djt_voters,
                muhat = cces_pct_djt_vv, 
                N = tot_votes, 
                n = cces_n_vv))
```

so can be implemented in a tibble as well:
```{r}
transmute(g2016, st,
          ddc = ddc(mu = pct_djt_voters, 
                    muhat = cces_pct_djt_vv, 
                    N = tot_votes,
                    n = cces_n_vv))
```

A negative $\rho$ means  $\rho = \text{Cor}(\textit{Respond}, \textit{Trump Supporter}) < 0$, i.e. Trump supporters were less likely to respond. 

